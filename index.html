<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>FNF Recreation in HTML, CSS and JavaScript</title>
      <style>
         body {
         display: flex;
         justify-content: center;
         align-items: center;
         height: 100vh;
         margin: 0;
         background-color: #f0f0f0;
         }
         #gameArea {
         width: 600px;
         height: 1000px;
         border: 1px solid #ccc;
         position: relative;
         overflow: hidden;
         }
         /* #strumline {
         position: absolute;
         width: 100%;
         height: 2px;
         background-color: #ff0000;
         top: 300px;
         animation: moveStrumline 1.5s linear infinite;
         } */
         #strumline {
         position: absolute;
         width: 100%;
         height: 2px;
         background-color: #ff0000;
         top: 300px;
         animation: moveStrumline 1.5s linear infinite;
         }
         .note {
         position: absolute;
         width: 50px;
         height: 50px;
         top: 1200px;
         transition: top 1s linear;
         display: flex;
         justify-content: center;
         align-items: center;
         /* font-size: 24px; */
         }
         .note[data-key="a"] {
         width: 162px;
         height: 146px;
         background-image: url('/fnf-recreation-in-html-js-php.github.io/NOTES/purple0000.png');
         }
         .note[data-key="arrowDown"] {
         width: 147px;
         height: 161px;
         background-image: url('/fnf-recreation-in-html-js-php.github.io/NOTES/blue0000.png');
         /* transform: rotate(90deg); */
         }
         .note[data-key="arrowUp"] {
         width: 147px;
         height: 161px;
         background-image: url('/fnf-recreation-in-html-js-php.github.io/NOTES/green0000.png');
         /* transform: rotate(90deg); */
         }
         .note[data-key="arrowRight"] {
         width: 162px;
         height: 146px;
         background-image: url('/fnf-recreation-in-html-js-php.github.io/NOTES/red0000.png');
         }
         .men {
         /* width: 50px; */
         /* height: 60px; */
         background-color: #ff0000;
         }
         .men1 {
         /* width: 50px; */
         /* height: 60px; */
         background-color: #ff0000;
         }
         .men2 {
         /* width: 50px; */
         /* height: 60px; */
         background-color: #ff0000;
         }
         @keyframes moveStrumline {
         0% {
         top: 300px;
         }
         100% {
         top: 500px;
         }
         }
         .game-sprite {
         position: absolute;
         }
      </style>
   </head>
   <body>
      <div id="score"></div>
      <div id="miss"></div>
      <div id="accuracy"></div>
      <div id="gameArea">
         <!-- <div class="tenor-gif-embed" data-postid="25339125" data-share-method="host" data-aspect-ratio="1.02564" data-width="100%"><a href="https://tenor.com/view/firestone-roblox-roundabout-crash-idiot-gif-25339125">Firestone Roblox GIF</a>from <a href="https://tenor.com/search/firestone-gifs">Firestone GIFs</a></div><script type="text/javascript" async src="https://tenor.com/embed.js"></script> -->
         <div id="strumline"></div>
      </div>
      <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.js"></script>
      <script>
         let balls = Boolean(false);
         let yes = Boolean(false);
         let leftNote;
         let upNote;
         let downNote;
         let rightNote;
         let frameIndex = 21;
         let groupLEFT;
         let groupUP;
         let groupDOWN;
         let groupRIGHT;
         let groupSTRUM;
         let groupSTRUMUP;
         let groupSTRUMDOWN;
         let groupSTRUMRIGHT;
         let groupSPLASH;
         let score = 0;
         let miss = 0;
         let strumX;
         let strumY;
         let accuracy = 0.00;
         var scoreDiv = document.getElementById("score");
         var missDiv = document.getElementById("miss");
         var accuracyDiv = document.getElementById("accuracy");
         let bpm;
         var strumXY;
         var elapsed;
         let curAnim;
         let num;
         let splashSkin;
         const config = {
         type: Phaser.WEBGL,
         width: 1920,
         height: 1080,
         parent: 'gameArea',
         transparent: true,
         scene: this
         };
         const game = new Phaser.Game(config);
         var songnamenonjson = 'last-chance';
         var songname = songnamenonjson +'.json';
         splashSkin = 'diamond';
         function preload() {
         // Load your XML file here
         this.load.atlasXML('notes', '/fnf-recreation-in-html-js-php.github.io/NOTE_assets-future.png', 'NOTE_assets-future.xml');
         this.load.atlasXML('splash', '/fnf-recreation-in-html-js-php.github.io/noteSplashes/noteSplashes-' + splashSkin + '.png', '/noteSplashes/noteSplashes-' + splashSkin + '.xml');
         }
         function createNoteGroup(scene, framePrefix) {
         return scene.add.group({
         key: 'notes',
         frame: framePrefix + '0000',
         frameQuantity: 3 * 3
         });
         }
         function createSplashGroup(scene, framePrefix) {
         return scene.add.group({
         key: 'splash',
         frame: framePrefix + '0000',
         frameQuantity: 3 * 3
         });
         }
         function create() {
             setTimeout(() => {
                 playSong();
             }, 600);
         
             // Access the loaded XML data
             const atlasTexture = this.textures.get('notes');
         
             for (let i = 21; i < 25; i++)
             {
             const animations = [
                 { key: 'arrowLEFT', prefix: 'arrowLEFT', end: 0 },
                 { key: 'arrowUP', prefix: 'arrowUP', end: 0 },
                 { key: 'arrowDOWN', prefix: 'arrowDOWN', end: 0 },
                 { key: 'arrowRIGHT', prefix: 'arrowRIGHT', end: 0 },
                 { key: 'purple', prefix: 'purple', end: 0 },
                 { key: 'blue', prefix: 'blue', end: 0 },
                 { key: 'green', prefix: 'green', end: 0 },
                 { key: 'red', prefix: 'red', end: 0 },
                 { key: 'leftConfirm', prefix: 'left confirm', end: 3 },
                 { key: 'leftPress', prefix: 'left press', end: 3 },
                 { key: 'upConfirm', prefix: 'up confirm', end: 3 },
                 { key: 'upPress', prefix: 'up press', end: 3 },
                 { key: 'downConfirm', prefix: 'down confirm', end: 3 },
                 { key: 'downPress', prefix: 'down press', end: 3 },
                 { key: 'rightConfirm', prefix: 'right confirm', end: 3 },
                 { key: 'rightPress', prefix: 'right press', end: 3 }
             ];
                         
             animations.forEach(animation => {
                 this.anims.create({
                     key: animation.key,
                     frames: this.anims.generateFrameNames('notes', { prefix: animation.prefix, end: animation.end, zeroPad: 4 }),
                     repeat: 0
                 });
             });
             for (let color of ['purple', 'green', 'blue', 'red']){
             const animationsSplash = [
                 { key: 'noteSplash' + color, prefix: "note splash " + splashSkin + ' ' +  color + " 1", end: 3 },
                 // { key: 'noteSplash2' + color, prefix: "note splash " + splashSkin + ' ' + color + " 2", end: 3 },
             ];
                         
             animationsSplash.forEach(animation => {
                 this.anims.create({
                     key: animation.key,
                     frames: this.anims.generateFrameNames('splash', { prefix: animation.prefix, end: animation.end, zeroPad: 4 }),
                     repeat: 0
                 });
             });
         }
             groupLEFT = createNoteGroup(this, 'arrowLEFT');
             groupUP = createNoteGroup(this, 'arrowUP');
             groupDOWN = createNoteGroup(this, 'arrowDOWN');
             groupRIGHT = createNoteGroup(this, 'arrowRIGHT');
             groupSPLASH = createSplashGroup(this, 'note splash ' + splashSkin + ' red 1');
             groupLEFT.playAnimation('arrowLEFT');
             groupUP.playAnimation('arrowUP');
             groupDOWN.playAnimation('arrowDOWN');
             groupRIGHT.playAnimation('arrowRIGHT');
             Phaser.Actions.GridAlign(groupLEFT.getChildren(), { width: 6, height: 6, cellWidth: 1, cellHeight: 1, x: 0, y: 0});
             Phaser.Actions.GridAlign(groupSPLASH.getChildren(), { width: 6, height: 6, cellWidth: 1, cellHeight: 1, x: 0, y: 0});
             Phaser.Actions.GridAlign(groupUP.getChildren(), { width: 6, height: 6, cellWidth: 1, cellHeight: 1, x: 310, y: 0});
             Phaser.Actions.GridAlign(groupDOWN.getChildren(), { width: 6, height: 6, cellWidth: 1, cellHeight: 1, x: 160, y: 0});
             Phaser.Actions.GridAlign(groupRIGHT.getChildren(), { width: 6, height: 6, cellWidth: 1, cellHeight: 1, x: 450, y: 0});       
             Phaser.Actions.ScaleXY(groupLEFT.getChildren(), 0.01, 0.01);       
             Phaser.Actions.ScaleXY(groupUP.getChildren(), 0.01, 0.01);       
             Phaser.Actions.ScaleXY(groupDOWN.getChildren(), 0.01, 0.01);       
             Phaser.Actions.ScaleXY(groupRIGHT.getChildren(), 0.01, 0.01);       
             Phaser.Actions.ScaleXY(groupSPLASH.getChildren(), 0.01, 0.01);
             this.startTime = this.game.getTime();
         }
         }
         function update() {
         elapsed = this.game.getTime() - this.startTime;
         scoreDiv.textContent = "Score: " + score;
         missDiv.textContent = " | Misses: " + miss;
         accuracyDiv.textContent = "| Accuracy: " + accuracy;
         let width = 100 * 0.6;
         switch (curAnim){
         case 'purple':
             num = 0;
             strumX = width * num * 0.6;
         case 'green':
             num = 1;
             strumX = width * num * 0.6;
         case 'blue':
             num = 2;
             strumX = width * num * 0.6;
         case 'red':
             num = 3;
             strumX = width * num * 0.6;
         }
         }
         function playSong() {
         var inst = new Audio('/fnf-recreation-in-html-js-php.github.io/songs/' + songnamenonjson + '/Inst.ogg');
         var voices = new Audio('/fnf-recreation-in-html-js-php.github.io/songs/' + songnamenonjson + '/Voices.ogg');
         var arr = new Array(inst, voices);
         for (let i in [0, 1])
         arr[i].play();
         
         if(inst.time != voices.time){
         inst.time = voices.time;
         }
         }
         const gameArea = document.getElementById('gameArea');
         document.addEventListener('keydown', handleKeyDown);
         document.addEventListener('keyup', handleKeyUp);
         
         function handleKeyDown(event) {
         const key = event.key.toLowerCase();
         
         switch (key) {
             case 'a':
             case 'arrowleft':
             checkHit(key);
             groupLEFT.playAnimation('leftPress');
             break;
             case 's':
             case 'arrowdown':
             checkHit(key);
             groupDOWN.playAnimation('downPress');
             break;
             case 'w':
             case 'arrowup':
             checkHit(key);
             groupUP.playAnimation('upPress');
             break;
             case 'd':
             case 'arrowright':
             checkHit(key);
             groupRIGHT.playAnimation('rightPress');
             break;
         }
         
         }
         function handleKeyUp(event) {
         const key = event.key.toLowerCase();
         
         switch (key) {
             case 'a':
             groupLEFT.playAnimation('arrowLEFT');
             break;
             case 'arrowdown':
             groupDOWN.playAnimation('arrowDOWN');
             break;
             case 'arrowup':
             groupUP.playAnimation('arrowUP');
             break;
             case 'arrowright':
             groupRIGHT.playAnimation('arrowRIGHT');
             break;
         }
         }
         function playNoteSound() {
             var audio = new Audio('/fnf-recreation-in-html-js-php.github.io/hitsound.mp3').play();
         }
         
         
         function checkHit(key) {
         const notes = document.getElementsByClassName('note');
         const scores = document.getElementById('strumline');
         
         for (const note of notes) {
         if (note && note.getAttribute('data-key')) {
             const noteKey = note.getAttribute('data-key').toLowerCase();
             if (note.offsetTop > -190 && note.offsetTop < 200 && key === noteKey) {
                 switch(noteKey){
                     case 'a':
                     groupLEFT.playAnimation('leftConfirm');
                     curAnim = 'purple';
                     groupSPLASH.playAnimation('noteSplash' + curAnim);
                     // groupSPLASH.playAnimation('noteSplash2' + curAnim);
                     break
                     case 'arrowup':
                     groupUP.playAnimation('upConfirm');
                     curAnim = 'green';
                     groupSPLASH.playAnimation('noteSplash' + curAnim);
                     // groupSPLASH.playAnimation('noteSplash2' + curAnim);
                     break
                     case 'arrowdown':
                     groupDOWN.playAnimation('downConfirm');
                     curAnim = 'blue';
                     groupSPLASH.playAnimation('noteSplash' + curAnim);
                     // groupSPLASH.playAnimation('noteSplash2' + curAnim);
                     break
                     case 'arrowright':
                     groupRIGHT.playAnimation('rightConfirm');
                     curAnim = 'red';
                     groupSPLASH.playAnimation('noteSplash' + curAnim);
                     // groupSPLASH.playAnimation('noteSplash2' + curAnim);
                     break
                 }
                 // Hit!
                 score += 350;
                 playNoteSound();
                 note.remove();
             }
         }
         }
         }
         function createNoteFromChart(timestamp, noteType) {
         const validNoteTypes = [0, 1, 2, 3, 4, 5, 6, 7, -1];
         if (!validNoteTypes.includes(noteType)) {
         console.error('Invalid noteType:', noteType);
         return; // Skip invalid note types :tr:
         }
         const note = document.createElement('div');
         note.className = 'note';
         let width = 160 * 0.52;
         note.style.left = (width * noteType * 1.85) + 'px';
         note.style.width = this.width * 0.7;
         
         if (noteType === -1) {
         // note.textContent = 'Show Song'; // events???
         } else{
         const arrowKeys = ['a', 'arrowDown', 'arrowUp', 'arrowRight', 'a', 's', 'd', 'f'];
         const arrowKey = arrowKeys[noteType];
         note.setAttribute('data-key', arrowKey);
         }
         gameArea.appendChild(note);
         
         setTimeout(() => {
         note.style.top = '-600px';
         }, timestamp);
         
         setTimeout(() => {
         note.remove();
         }, timestamp + 1200);
         }
         function loadChartFromJsonFile(jsonFilePath) {
             return fetch(jsonFilePath)
                 .then(response => response.json())
                 .then(chartData => {
                     console.log('Loaded chartData:', chartData);
                     bpm = chartData.song.notes[1].bpm;
                     // scrollSpeed = chartData.song.notes[1].speed;
                     if (chartData && Array.isArray(chartData.song.notes)) {
                         for (const section of chartData.song.notes) {
                             if (section.sectionNotes && section.sectionNotes.length > 2) {
                                 for (const noteData of section.sectionNotes) {
                                     let noteType = section.sectionNotes[0][1];
                                     let Noteshit;
                                     let strumTime = noteData[0];
                                     let gottaHitNote = section.mustHitSection;
                                     let susLength = section.sustainLength;
                                     susLength = susLength / bpm % 100;
                                     if (noteData[1] > 3){
                                     gottaHitNote = !section.mustHitSection;
                                     }
                                     sustainLength = noteData[2];
                                     // console.log(sustainLength);
                                     //altNote = noteData[3];
                                     // let songNoteData = parseInt(noteData[1] % 8);
                                     if (Array.isArray(noteData) && noteData.length >= 2) {
                                         let songNoteDataP1 = parseInt(noteData[1] % 4);
                                     if (gottaHitNote){   
                                         createNoteFromChart(noteData[0], songNoteDataP1);
                                         // for (susNote in Math.floor(susLength))
                                         // createNoteFromChart(susLength, susNote);
                                     }
                                     //     // createNoteFromChart(noteData[0], songNoteDataP1);     
                                     // }
                                     } else {
                                         console.error('Invalid noteData:', noteData);
                                     }
                                 }
                             }
                         }
                     } else {
                         console.error('Invalid or missing chartData.song.notes:', chartData && chartData.song.notes);
                     }
                 })
                 .catch(error => console.error('Error loading chart:', error));
         }
         
         // Load chart from songs/`${songnamenonjson}/${songname}.json`
         loadChartFromJsonFile(songname);
         
         // scroll speed basically
         // setInterval(() => {
         //     const timestamp = Date.now();
         //     const noteType = 1 * 3;
         //     // console.log(noteType);
         //     createNoteFromChart(timestamp, noteType);
         // }, 1500);
         
      </script>
   </body>
</html>
