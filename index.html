<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        #gameArea {
            width: 600px;
            height: 400px;
            border: 1px solid #ccc;
            position: relative;
            overflow: hidden;
        }

        #strumline {
            position: absolute;
            width: 100%;
            height: 2px;
            background-color: #ff0000;
            top: 300px;
            animation: moveStrumline 1.5s linear infinite;
        }

        #strumline {
            position: absolute;
            width: 100%;
            height: 2px;
            background-color: #ff0000;
            top: 300px;
            animation: moveStrumline 1.5s linear infinite;
        }

        .note {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: #3498db;
            top: 0;
            transition: top 1s linear;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: #fff;
        }

        .indicator {
            position: absolute;
            width: 50px;
            height: 60px;
            background-color: #000;
            top: 350px; /* Adjusted the top position to be in the middle */
            transition: top 0.5s linear;
        }
        .indicatorP2 {
            position: absolute;
            width: 50px;
            height: 60px;
            background-color: #000;
            top: 0px; /* Adjusted the top position to be in the middle */
            transition: top 0.5s linear;
        }

        @keyframes moveStrumline {
            0% {
                top: 300px;
            }

            100% {
                top: 500px;
            }
        }
        .game-sprite {
            position: absolute;
        }
    </style>
</head>

<body>
    <div id="gameArea">
        <div id="strumline"></div>
        <div class="indicator" style="left: 0px;"></div>
        <div class="indicator" style="left: 150px;"></div>
        <div class="indicator" style="left: 300px;"></div>
        <div class="indicator" style="left: 450px;"></div>
        <div class="indicatorP2" style="left: 0px;"></div>
        <div class="indicatorP2" style="left: 150px;"></div>
        <div class="indicatorP2" style="left: 300px;"></div>
        <div class="indicatorP2" style="left: 450px;"></div>
    </div>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.80.0/dist/phaser.js"></script>

    <script>
        let balls = Boolean(false);

const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

const game = new Phaser.Game(config);

function preload() {
    // Load your XML file here
    this.load.atlasXML('notes', 'NOTE_assets-future.png', 'NOTE_assets-future.xml');
}

function create() {
    setTimeout(() => {
        playSong();
        
    }, 500);
    // Access the loaded XML data
    const atlasTexture = this.textures.get('notes');

    const frames = atlasTexture.getFrameNames();
    // const xy = atlasTexture.getFrameBounds();

    // Create an array to store animations
    const anims = [];

    for (let i = 0; i < frames.length; i++) {
        const frameData = [
        { x: 751,
          y: 243,
          width: 146, 
          height: 162, 
          frameX: -50, 
          frameY: -5, 
          frameWidth: 50, 
          frameHeight: 50
         },
        // Add more frame data objects for each frame
    ];
        const frameNameNoNum = [];
        // const fuck = xy[i];
        const frameName = frames[2];
        // const frameConfig = frameData[i];

        // if (!frameConfig) {
        //     console.error(`Frame data missing for ${frameName}`);
        //     continue;
        // }

        // const { x, y, width, height, frameX, frameY, frameWidth, frameHeight } = frameConfig;

        // Create an animation config for each frame
        // const config1 = {
        //     key: frames[1],
        //     frames: this.anims.generateFrameNumbers('notes', { start: 0, end: 3 }),
        //     frameRate: 10, // Adjust as needed
        //     repeat: 0 // 0 means play once, adjust as needed
        // };
        // const config2 = {
        //     key: frames[0],
        //     frames: this.anims.generateFrameNumbers('notes', { start: 0, end: 3 }),
        //     frameRate: 10, // Adjust as needed
        //     repeat: 0 // 0 means play once, adjust as needed
        // };
        // const config3 = {
        //     key: frames[3],
        //     frames: this.anims.generateFrameNumbers('notes', { start: 0, end: 3 }),
        //     frameRate: 10, // Adjust as needed
        //     repeat: 0 // 0 means play once, adjust as needed
        // };
        // const config4 = {
        //     key: frames[2],
        //     frames: this.anims.generateFrameNumbers('notes', { start: 0, end: 3 }),
        //     frameRate: 10, // Adjust as needed
        //     repeat: 0 // 0 means play once, adjust as needed
        // };

        // Add the animation config to the array
        // anims.push(config1);
        // anims.push(config2);
        // anims.push(config3);
        // anims.push(config4);
        // this.anims.create(config1);
        // this.anims.create(config2);
        // this.anims.create(config3);
        // this.anims.create(config4);
    }
        for (let i = 0; i < 4; i++) {
            // Play the animation when the corresponding key is pressed
            if (!Boolean(balls)){
         this.add.image(100, 399, 'notes', frames[1]);
         this.add.image(250, 399, 'notes', frames[0]);
         this.add.image(400, 399, 'notes', frames[3]);
         this.add.image(550, 399, 'notes', frames[2]);

                //  this;
    }else if(Boolean(balls)){


        //  var spr1 = this.add.sprite(100, 399, 'notes',).play('down confirm0001');
        //  var spr1 = this.add.sprite(250, 399, 'notes', 'up press0000');
            //  spr1 = this.add.sprite(250, 399, 'notes', 'up press0001');
            //  spr1 = this.add.sprite(250, 399, 'notes', 'up press0002');
            //  spr1 = this.add.sprite(250, 399, 'notes', 'up press0003');
            // this.add.sprite(400, 399, 'notes').play('down confirm0002');
            // this.add.sprite(550, 399, 'notes').play('right confirm000');
            console.log(balls);
    }}
    // Log the animations array for verification
    // console.log(anims);
    // console.log(xy);
}
// document.addEventListener('keydown', update); 

// function keyPress(event){
//         penis = event.key.toLowerCase();
//             if(penis === 'arrowLeft')
//             this.add.sprite(300, 200).play('explode1');
//         this.add.sprite(400, 200).play('explode2');

//         this.add.sprite(300, 400).play('bobble1');
//         this.add.sprite(400, 400).play('bobble2');
//     }


function update() {
    if(Boolean(balls)){
        for (let i = 0; i < 4; i++) {
        //  var spr1 = this.add.sprite(100, 399, 'notes',).play('down confirm0001');
        const upPress = {
            key: ' ',
            frames: this.anims.generateFrameNumbers('up press000', { start: 0, end: 3 }),
            frameRate: 10,
            repeat: -1
        };
        this.anims.create(upPress);
        // anims.push(upPress);
        this.add.sprite(400, 400).play('notes');
            
             // this.add.sprite(400, 399, 'notes').play('down confirm0002');
            // this.add.sprite(550, 399, 'notes').play('right confirm000');
            console.log(balls);
        balls = Boolean(false);
        // var spr1 = this.add.sprite(100, 399).play;
        var spr1 = this.add.sprite(100, 399, 'notes','left confirm0001');
        var spr1 = this.add.sprite(100, 399, 'notes','left confirm0002');
            //  spr1 = this.add.sprite(100, 399, 'notes','left confirm0003');
    }}
    // Log the animations array for verification
    // console.log(anims);
    // console.log(xy);
    // Update game logic here
    // penis = event.key.toLowerCase();
            // if(new Boolean(true))
            // for (let i = 0; i < 5; i++) {
        // this.add.sprite(300, 200).play('arrow');
        // this.add.sprite(400, 200).play('explode2');

        // this.add.sprite(400, 399).play(frames[45]);
        // this.add.sprite(400, 400).play('bobble2'  + i);
            // }
    }

function parseNotes(xmlData) {
    // Extract note information from XML
    const notes = xmlData.getElementsByTagName('SubTexture');

    // Iterate through notes and create sprites
    for (let i = 0; i < notes.length; i++) {
        const note = notes[i];

        // Extract attributes like name, x, y, width, height
        const name = note.getAttribute('name');
        const x = parseInt(note.getAttribute('x'));
        const y = parseInt(note.getAttribute('y'));

        // Create a sprite for each note
        const noteSprite = this.add.sprite(x, y, 'notes', name); // Use 'this' from the surrounding scope

        // Add your custom logic for handling notes
    }
}


    var songnamenonjson = 'all-stars';
    var songname = 'all-stars.json';
        function parseSprites(spriteXml) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(spriteXml, "text/xml");

            const sprites = xmlDoc.getElementsByTagName("SubTexture");
            for (const sprite of sprites) {
                const spriteName = sprite.getAttribute("name");
                const spriteX = parseInt(sprite.getAttribute("x"));
                const spriteY = parseInt(sprite.getAttribute("y"));
                const spriteWidth = parseInt(sprite.getAttribute("width"));
                const spriteHeight = parseInt(sprite.getAttribute("height"));

                const spriteElement = document.createElement("img");
                spriteElement.src = xmlDoc.documentElement.getAttribute("imagePath");
                spriteElement.alt = spriteName;
                spriteElement.className = "game-sprite";
                spriteElement.style.left = spriteX + "px";
                spriteElement.style.top = spriteY + "px";
                spriteElement.width = spriteWidth;
                spriteElement.height = spriteHeight;

                gameArea.appendChild(spriteElement);
            }
        }

        function loadSpritesFromXmlFile(xmlFilePath) {
            return fetch(xmlFilePath)
                .then(response => response.text())
                .then(xmlData => {
                    parseSprites(xmlData);
                })
                .catch(error => console.error('Error loading XML file:', error));
        }

        // loadSpritesFromXmlFile('sprites.xml');

function parseRhythmGameChart(songJson) {
    if (songJson.gfVersion == null) {
        songJson.gfVersion = songJson.player3;
        songJson.player3 = null;
    }

    if (songJson.events == null) {
        songJson.events = [];

        for (let secNum = 0; secNum < songJson.notes.length; secNum++) {
            const sec = songJson.notes[secNum];
            let i = 0;
            const notes = sec.sectionNotes;
            let len = notes.length;

            while (i < len) {
                const note = notes[i];

                if (note[1] < 0) {
                    songJson.events.push([note[0], [[note[1], note[2], note[3]]]]);
                    notes.splice(i, 1);
                    len = notes.length;
                } else {
                    i++;
                }
            }
        }
    }
}

function playSong() {
    var inst = new Audio('/songs/' + songnamenonjson + '/Inst.ogg').play();
        var voices = new Audio('/songs/' + songnamenonjson + '/Voices.ogg').play();
    }


             const gameArea = document.getElementById('gameArea');
        document.addEventListener('keydown', handleKeyDown);

        function handleKeyDown(event) {
    const key = event.key.toLowerCase();

    switch (key) {
        case ' ':
            break;
        case 'arrowleft':
        balls = Boolean(true);
            // const sprite = this.add.sprite(400, 399, 'notes', frames[45]);
            // sprite.play(fraames[45]);
            break;

            case 'a':
            checkHit(key);
            break;
            case 'arrowdown':
            checkHit(key);
            break;
            case 'arrowup':
            checkHit(key);
            break;
            case 'arrowright':
            checkHit(key);
            break;
    }

        // Add more cases for other keys as needed
}

        function playNoteSound() {
            var audio = new Audio('hitsound.mp3').play();
        }


        function checkHit(key) {
    const notes = document.getElementsByClassName('note');

    for (const note of notes) {
        // Check if note and note.getAttribute('data-key') are not null before accessing properties
        if (note && note.getAttribute('data-key')) {
            const noteKey = note.getAttribute('data-key').toLowerCase();

            if (note.offsetTop > 270 && note.offsetTop < 350 && key === noteKey) {
                // Hit!
                playNoteSound();
                note.remove();
            }
        }
    }
}

        function createNoteFromChart(timestamp, noteType) {
    const validNoteTypes = [0, 1, 2, 3, 4, 5, 6, 7, -1];
    if (!validNoteTypes.includes(noteType)) {
        console.error('Invalid noteType:', noteType);
        return; // Skip invalid note types
    }

    const note = document.createElement('div');
    note.className = 'note';
    note.style.left = (150 * noteType) + 'px';

    if (noteType === -1) {
        note.textContent = 'Show Song'; // Adjust as needed for -1
    } else {
        const arrowKeys = ['a', 'arrowDown', 'arrowUp', 'arrowRight', 'a', 's', 'd', 'f'];
        const arrowKey = arrowKeys[noteType];
        note.setAttribute('data-key', arrowKey);
        note.textContent = arrowKey.toUpperCase();
    }

    gameArea.appendChild(note);

    setTimeout(() => {
        note.style.top = '400px';
    }, timestamp);

    setTimeout(() => {
        note.remove();
    }, timestamp + 1000);
}
        function loadChartFromJsonFile(jsonFilePath) {
            return fetch(jsonFilePath)
                .then(response => response.json())
                .then(chartData => {
                    console.log('Loaded chartData:', chartData);

                    if (chartData && Array.isArray(chartData.song.notes)) {
                        for (const section of chartData.song.notes) {
                            if (section.sectionNotes && section.sectionNotes.length > 0) {
                                for (const noteData of section.sectionNotes) {
                                    if (Array.isArray(noteData) && noteData.length >= 2) {
                                        createNoteFromChart(noteData[0], noteData[1]);
                                    } else {
                                        console.error('Invalid noteData:', noteData);
                                    }
                                }
                            }
                        }
                    } else {
                        console.error('Invalid or missing chartData.song.notes:', chartData && chartData.song.notes);
                    }
                })
                .catch(error => console.error('Error loading chart:', error));
        }

        // Load chart from "its-a-me.json"
        loadChartFromJsonFile(songname);

        // Interval to create random notes (modify as needed)
        setInterval(() => {
            const timestamp = Date.now();
            const noteType = Math.floor(Math.random() * 4);
            createNoteFromChart(timestamp, noteType);
        }, 1500);

        
    </script>
</body>

</html>
